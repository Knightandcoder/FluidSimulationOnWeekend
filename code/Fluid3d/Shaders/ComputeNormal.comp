#version 450 core
layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(rgba32f, binding = 0) uniform image2D inputPosition;
layout(rgba32f, binding = 1) uniform image2D outputNormal;

struct Material {
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
    float shininess;
};

struct Light {
    vec3 position;
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
};

Material mat1 = {
    vec3(1.0, 1.0, 0.9),
    vec3(1.0, 1.0, 0.9),
    vec3(0.5, 0.5, 0.5),
    32.0
};

Light light1 = {
    vec3(1.0, 1.0, 1.0),
    vec3(0.2, 0.2, 0.2),
    vec3(0.5, 0.5, 0.5),
    vec3(1.0, 1.0, 1.0)
};

vec3 viewPos = vec3(0.0, 0.0, 0.0);

vec3 Phong(vec3 position, vec3 normal) {
    // 环境光
    vec3 ambient = light1.ambient * mat1.ambient;

    // 漫反射 
    vec3 lightDir = normalize(light1.position - position);
    float diff = max(dot(normal, lightDir), 0.0);
    vec3 diffuse = light1.diffuse * (diff * mat1.diffuse);

    // 镜面光
    vec3 viewDir = normalize(viewPos - position);
    vec3 reflectDir = reflect(-lightDir, normal);  
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), mat1.shininess);
    vec3 specular = light1.specular * (spec * mat1.specular);

    return ambient + diffuse + specular;
}


float fxInv = 0.0011547;    // 2 * tan(fovx/2) / w
float fyInv = 0.0011547;    // 2 * tan(fovy/2) / w
float cx = 500;
float cy = 500;
vec3 DepthToPosition(float depth, ivec2 imageCoord) { 
    float x = abs(depth) * (float(imageCoord.x) - cx) * fxInv;
    float y = abs(depth) * (float(imageCoord.y) - cy) * fyInv;   
    return vec3(x, y, depth);
}

void main() {
    ivec2 curPixelId = ivec2(gl_GlobalInvocationID.xy);
    if (imageLoad(inputPosition, curPixelId).a < 0.1) {
        imageStore(outputNormal, curPixelId, vec4(0.0, 0.0, 0.0, 0.05));
        return;
    }

    float curDepth = imageLoad(inputPosition, curPixelId).x;
    float upDepth = imageLoad(inputPosition, curPixelId + ivec2(0, 1) * 2).x;
    float downDepth = imageLoad(inputPosition, curPixelId + ivec2(0, -1) * 2).x;
    float leftDepth = imageLoad(inputPosition, curPixelId + ivec2(-1, 0) * 2).x;
    float rightDepth = imageLoad(inputPosition, curPixelId + ivec2(1, 0) * 2).x;
    
    vec3 curPos = DepthToPosition(curDepth, curPixelId);
    vec3 upPos = DepthToPosition(upDepth, curPixelId + ivec2(0, 1) * 2);
    vec3 downPos = DepthToPosition(downDepth, curPixelId + ivec2(0, -1) * 2);
    vec3 leftPos = DepthToPosition(leftDepth, curPixelId + ivec2(-1, 0) * 2);
    vec3 rightPos = DepthToPosition(rightDepth, curPixelId + ivec2(1, 0) * 2);


    vec3 tangentURight = rightPos - curPos;
    vec3 tangentULeft = curPos - leftPos;
    vec3 tangentVDown = curPos - downPos;
    vec3 tangentVUp = upPos - curPos;
    
    vec3 tangentU;
    if (abs(tangentULeft.z) > abs(tangentURight.z)) {
        tangentU = normalize(tangentURight);
    }
    else {
        tangentU = normalize(tangentULeft);
    }

    vec3 tangentV;
    if (abs(tangentVUp.z) > abs(tangentVDown.z)) {
        tangentV = normalize(tangentVDown);
    }
    else {
        tangentV = normalize(tangentVUp);
    }

    vec3 surfaceNormal = cross(tangentU, tangentV);

    vec3 FragColor = Phong(curPos, surfaceNormal);

    imageStore(outputNormal, curPixelId, vec4(surfaceNormal, 1.0));

    return;
}